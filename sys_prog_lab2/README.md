# Лабораторна робота: Лексичний аналізатор PHP

Виконання лабораторної роботи з дисципліни "Системне програмування".

Цей проект є реалізацією лексичного аналізатора для підмножини мови PHP, написаного на C++. Він розроблений для виконання завдань лабораторної роботи, що включає розпізнавання різних класів лексем.

Головною особливістю цього проекту є реалізація **двох** окремих підходів до лексичного аналізу, як того вимагали умови завдання, з метою порівняння їхньої коректності та ефективності.

## Функціонал

* **Реалізація 1 (`LexerRegex`):** Лексичний аналізатор, що повністю базується на `std::regex`. Виконує базове завдання на 3 бали.
* **Реалізація 2 (`LexerFSM`):** Альтернативний, високопродуктивний лексичний аналізатор, реалізований як ручний скінченний автомат (FSM). Виконує опціональне завдання на +4 бали.
* **Тестування:** Програма автоматично запускає обидва лексери на двох вбудованих тестових наборах (`TEST1` та `TEST2`).
* **Верифікація:** Вбудована функція `compare_results` по-токенно порівнює результати обох лексерів і повідомляє про будь-які розбіжності.
* **Бенчмаркінг:** Програма вимірює та друкує час виконання кожного аналізатора в мілісекундах.

## Збірка та Запуск

Для компіляції та запуску проекту потрібен компілятор C++, що підтримує стандарт C++17 (або новіший), оскільки використовується `std::regex`.

1.  **Компіляція** (рекомендується увімкнути оптимізацію `-O2` для коректного бенчмаркінгу):
    ```bash
    g++ -std=c++17 -o lexer main.cpp -O2
    ```

2.  **Запуск:**
    ```bash
    ./lexer
    ```

## Як це працює

Програма містить дві ключові структури, кожна з яких є повноцінним лексичним аналізатором.

### 1. `LexerRegex` (Базове завдання)

Цей підхід виконує вимогу "розбиття на лексеми регулярними виразами".

* **Принцип:** У конструкторі він динамічно будує один гігантський `std::regex`, об'єднуючи всі правила (для чисел, рядків, операторів і т.д.) через оператор `|`. Кожне правило загортається в `(...)` (групу захоплення).
* **Порядок правил:** Порядок є критичним. Наприклад, правило для `VARIABLE` (`"\\$[a-zA-Z_]..."`) має йти *перед* `IDENT`, інакше `$name` буде розпізнано неправильно.
* **Виконання:** Використовує `std::sregex_iterator` для послідовного пошуку *всіх* збігів цього гігантського виразу у вхідному коді.
* **Недолік:** Як демонструють результати, цей метод є **значно повільнішим** (в ~50-60 разів) за ручну реалізацію і дуже складний у налагодженні через правила екранування C++.

### 2. `LexerFSM` (Опціональне завдання)

Це реалізація лексичного аналізу через ручний **скінченний автомат (FSM)**.

* **Принцип:** Це класичний посимвольний аналіз. Лексер має стан (позиція `pos`, рядок `line`, колонка `col`) і приймає рішення, дивлячись на поточний символ.
* **`peek()` vs `get()`:** "Двигун" лексера. `peek()` "підглядає" наперед, не зсуваючи курсор (наприклад, щоб відрізнити `/` від `//`), а `get()` споживає символ і зсуває курсор.
* **Maximal Munch:** Проблема "максимального поглинання" (наприклад, розпізнати `??=` а не `??` та `=`) вирішується за допомогою єдиного, відсортованого за довжиною списку `ALL_OPS`. Лексер завжди намагається знайти найдовший можливий оператор зі списку.

## Результати та Порівняння

Вивід програми демонструє повну ідентичність результатів обох лексерів та кардинальну різницю у швидкодії.

* `LexerRegex` (`std::regex`) є простим у написанні правил, але **дуже повільним** у виконанні.
* `LexerFSM` (ручний автомат) вимагає більше коду, але є **неймовірно швидким**, оскільки це просто посимвольний прохід по пам'яті.
